name: Multi-Cloud Infra + Hot Deploy (AKS/EKS)

on:
  push:
    branches: [ "main" ]
    paths:
      - 'infra/**'
      - 'app/**'
      - 'k8s/**'
      - '.github/workflows/deploy.yml'

env:
  CLOUD: ${{ secrets.CLOUD }} # 'azure' or 'aws'

jobs:
  terraform:
    name: Provision Infrastructure
    runs-on: ubuntu-latest
    outputs:
      tf-output: ${{ steps.capture.outputs.tf-output }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v2

      # Terraform init & apply
      - name: Terraform Apply
        id: capture
        run: |
          cd infra
          terraform init
          terraform apply -auto-approve
          # Capture all outputs
          terraform output -json > tf-output.json
          echo "::set-output name=tf-output::$(cat tf-output.json | jq -c .)"

      # Optional: show outputs
      - name: Show Terraform outputs
        run: |
          echo "${{ steps.capture.outputs.tf-output }}"

  deploy:
    name: Build Image & Hot-Deploy
    runs-on: ubuntu-latest
    needs: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - name: Install jq
        run: sudo apt-get install -y jq

      # Parse Terraform outputs dynamically
      - name: Parse Terraform outputs
        id: parse
        run: |
          echo "${{ needs.terraform.outputs.tf-output }}" > tf-output.json
          if [ "${{ env.CLOUD }}" = "azure" ]; then
            export AKS_RG=$(jq -r '.aks_rg.value' tf-output.json)
            export AKS_NAME=$(jq -r '.aks_name.value' tf-output.json)
            export ACR_NAME=$(jq -r '.acr_login_server.value' tf-output.json)
            echo "AKS_RG=$AKS_RG" >> $GITHUB_ENV
            echo "AKS_NAME=$AKS_NAME" >> $GITHUB_ENV
            echo "ACR_NAME=$ACR_NAME" >> $GITHUB_ENV
          else
            export EKS_NAME=$(jq -r '.eks_name.value' tf-output.json)
            export ECR_REGISTRY=$(jq -r '.ecr_repo_url.value' tf-output.json)
            echo "EKS_NAME=$EKS_NAME" >> $GITHUB_ENV
            echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV
          fi

      # ---------- Build Docker Image ----------
      - name: Build Docker Image
        run: |
          IMAGE_TAG=${GITHUB_SHA}
          if [ "${{ env.CLOUD }}" = "azure" ]; then
            IMAGE="$ACR_NAME/myapp:$IMAGE_TAG"
          else
            IMAGE="$ECR_REGISTRY:$IMAGE_TAG"
          fi
          docker build -t "$IMAGE" .
          docker push "$IMAGE"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          echo "TAG=$IMAGE_TAG" >> $GITHUB_ENV

      # ---------- Connect to Cluster ----------
      - name: AKS: Get Credentials
        if: env.CLOUD == 'azure'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: AKS: Set kubeconfig
        if: env.CLOUD == 'azure'
        run: |
          az aks get-credentials --resource-group $AKS_RG --name $AKS_NAME --overwrite-existing

      - name: EKS: Configure kubeconfig
        if: env.CLOUD == 'aws'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: EKS: Update kubeconfig
        if: env.CLOUD == 'aws'
        run: aws eks update-kubeconfig --name $EKS_NAME --region ${{ secrets.AWS_REGION }}

      # ---------- Deploy to Kubernetes ----------
      - name: Render deployment with image tag
        run: |
          sed "s|<IMAGE_URL>|${IMAGE}|g; s|<IMAGE_TAG>|${TAG}|g" k8s/deployment.yaml > k8s/deployment.rendered.yaml

      - name: Apply manifests
        run: |
          kubectl apply -f k8s/pvc.yaml
          kubectl apply -f k8s/service.yaml
          kubectl apply -f k8s/deployment.rendered.yaml

      - name: Wait for rollout
        run: kubectl rollout status deployment/myapp --timeout=5m
